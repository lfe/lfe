.TH "lfe" "1" "2008\-2016" "" ""
.SH NAME
.PP
lfe \- Lisp Flavoured Erlang (LFE) shell
.SH SYNOPSIS
.PP
\f[C]lfe\f[] is a simple LFE repl (read\-eval\-print loop) in which you
can enter sexprs which then are evaluated and the value printed.
You can also define local functions and macros as well as set variables.
It can read commands either from the standard input or from a file.
.PP
The LFE repl is implemented in the module \f[C]lfe_shell\f[].
.SH BUILT\-IN SHELL FUNCTIONS
.PP
These are defined as normal functions and macros and can be called from
anywhere in the shell.
They can even be redefined.
They can also be explicitly called (: lfe_shell ...).
.PP
\f[B](c File [Options])\f[]
.PP
Compile and load an LFE file.
Assumes default extension \f[C]\&.lfe\f[].
.PP
\f[B](cd Dir)\f[]
.PP
Change the working directory.
.PP
\f[B](ec File [Options])\f[]
.PP
Compile and load an Erlang file.
.PP
\f[B](flush)\f[]
.PP
Flush any messages sent to the shell.
.PP
\f[B](i)\f[]
.PP
Print information about the currently running processes in the system.
.PP
\f[B](l Module ...)\f[]
.PP
Load modules.
.PP
\f[B](m Module ...)\f[]
.PP
Print out module information, if no modules are given then print
information about all modules.
.PP
\f[B](pid x y z)\f[]
.PP
Create a pid from x, y, z.
.PP
\f[B](p Expr)\f[]
.PP
\f[B](pp Expr)\f[]
.PP
Print/prettyprint a value to full depth.
.PP
\f[B](pwd)\f[]
.PP
Print the current working directory.
.PP
\f[B](regs)\f[]
.PP
Print information about the registered processes in the system.
.PP
\f[B](: c Command Arg ...)\f[]
.PP
\f[B](c:Command Arg ...)\f[]
.PP
All the commands in the standard Erlang shell can be reached in this
way.
.SH BUILT\-IN SHELL COMMANDS
.PP
These are special forms which are only recognised at the top\-level in
shell input.
The cannot be redefined.
.PP
\f[B](reset\-environment)\f[]
.PP
Resets the environment to its initial state.
This will clear all variables, functions an macros that have been set.
.PP
\f[B](set Pattern Expr)\f[]
.PP
\f[B](set Pattern (when Guard) Expr)\f[]
.PP
Evaluate Expr and match the result with Pattern binding variables in it.
These variables can then be used in the shell and also rebound in
another set.
.PP
\f[B](slurp File)\f[]
.PP
Slurp in a source LFE file and makes all functions and macros defined in
the file available in the shell.
Only one file can be slurped at a time and slurping a new file basically
does an unslurp first.
.PP
\f[B](unslurp)\f[]
.PP
Revert back to the state before the last slurp removing all function and
macro definitions both in the slurped file and defined in the shell
since then.
.PP
\f[B](run File)\f[]
.PP
Execute all the shell commands in File.
All defined variables, functions and macros will be saved in the
environment if there are no errors.
.SH SHELL FUNCTIONS AND MACROS
.PP
Functions and macros can be defined in the shell.
These will only be local to the shell and cannot be called from modules.
The forms are the standard forms for defining functions and macros.
.PP
\f[B](defun Fun ...)\f[]
.PP
Define a function in the shell.
.PP
\f[B](defmacro Macro ...)\f[]
.PP
Define a macro in the shell.
.SH BUILT\-IN SHELL VARIABLES
.PP
\f[B]\f[C]+\f[], \f[C]++\f[], \f[C]+++\f[]\f[]
.PP
The three previous expressions input.
.PP
\f[B]\f[C]*\f[], \f[C]**\f[], \f[C]***\f[]\f[]
.PP
The values of the previous 3 expressions.
.PP
\f[B]\f[C]\-\f[]\f[]
.PP
The current expression input.
.SH SHELL ENVIRONMENT
.PP
The shell maintains an environment of local function and macro
definitions, and variable bindings.
The environment can be accessed using the built\-in shell variable $ENV.
This can be useful when calling functions like macroexpand and
macro\-function which unless an explicit environment is given will only
search the default environment.
.SH STARTING THE LFE SHELL
.PP
After installing the best way is probably to start Erlang directly
running the LFE shell with:
.IP
.nf
\f[C]
lfe\ [flags]
\f[]
.fi
.PP
From a normal Erlang shell the best way to start the shell is by
calling:
.IP
.nf
\f[C]
17>\ lfe_shell:server().
\f[]
.fi
.PP
Giving the user switch commands:
.IP
.nf
\f[C]
\-\->\ s\ lfe_shell
\-\->\ c
\f[]
.fi
.PP
will create a job running the LFE shell and connect to it.
This also works when starting a remote shell.
.SH RUNNING LFE SHELL SCRIPTS
.PP
The LFE shell can also be directly called to run LFE shell scripts with:
.IP
.nf
\f[C]
lfe\ [flags]\ file\ [args]
\f[]
.fi
.PP
This will start the shell, run a script with LFE shell commands and then
terminate the shell.
The following built\-in variables are also bound:
.PP
\f[B]script\-name\f[]
.PP
The name of the script file as a string.
.PP
\f[B]script\-args\f[]
.PP
A list of the arguments to the script as strings.
If no arguments have been given then this will be an empty list.
.SH RUNNING A HEADLESS SHELL
.PP
LFE comes with a \f[C]gen_server\f[] shell in the \f[C]lfe_server\f[]
module.
This allows the developer to start an LFE server which solely supports a
programmatic interface, not an interactive one (it does not write to
stdout, including not displaying a start\-up banner).
All input is sent to the server via the \f[C]send/1\f[] function defined
for the server\[aq]s API.
.PP
When calling \f[C]send/1\f[], the developer passes a quoted LFE
expression which is then handled by \f[C]lfe_server:handle_call/3\f[].
A successfull call results in a returned evaluation of the quoted
expression that was called.
An error currently causes the process server to die, thus losing REPL
state.
.PP
Usage looks like the following:
.IP
.nf
\f[C]
>\ (lfe_server:start)
#(ok\ <0.35.0>)
>\ (lfe_server:send\ \[aq](defun\ adder\ (a\ b)\ (+\ a\ b)))
adder
>\ (lfe_server:send\ \[aq](adder\ 10\ 20))
30
>\ (lfe_server:send\ \[aq](set\ val\ (adder\ 10\ 20)))
30
>\ (lfe_server:send\ \[aq]val)
30
\f[]
.fi
.PP
The \f[C]lfe_server\f[] server process may be easily added to a
supervision tree, and in fact this is encouraged for any serious use of
a headless LFE shell server.
It goes without saying that any number of servers may be started in a
supervision tree, each with their own dedciated LFE environment.
.SH SEE ALSO
.PP
\f[B]lfescript(1)\f[], \f[B]lfe_guide(7)\f[]
.SH AUTHORS
Robert Virding.
