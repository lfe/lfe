.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "lfe_guide" "7" "2008\-2016" "" ""
.hy
.SH NAME
.PP
lfe_guide \- Lisp Flavoured Erlang User Guide
.SH SYNPOSIS
.PP
Note: {{ ...
}} is use to denote optional syntax.
.SH LITERALS AND SPECIAL SYNTACTIC RULES
.SS Integers
.PP
Integers can be written in various forms and number bases:
.IP \[bu] 2
Regular decimal notation:
.IP
.nf
\f[C]
\ \ 1234\ \-123\ 0
\f[]
.fi
.IP \[bu] 2
Binary notation:
.IP
.nf
\f[C]
\ \ #b0\ #b10101\ #b\-1100
\f[]
.fi
.IP \[bu] 2
Binary notation (alternative form):
.IP
.nf
\f[C]
\ \ #*0\ #b*10101\ #*\-1100
\f[]
.fi
.IP \[bu] 2
Octal notation:
.IP
.nf
\f[C]
\ \ #o377\ #o\-111
\f[]
.fi
.IP \[bu] 2
Explicitly decimal notation:
.IP
.nf
\f[C]
\ \ #d1234\ #d\-123\ #d0
\f[]
.fi
.IP \[bu] 2
Hexadecimal notation:
.IP
.nf
\f[C]
\ \ #xc0ffe\ 0x\-01
\f[]
.fi
.IP \[bu] 2
Notation with explicit base (up to 36):
.IP
.nf
\f[C]
\ \ #2r1010\ #8r377\ #36rhelloworld
\f[]
.fi
.IP \[bu] 2
Character notation (the value is the Unicode code point of the
character):
.IP
.nf
\f[C]
\ \ #\\a\ #\\$\ #\\ä
\f[]
.fi
.IP \[bu] 2
Character notation with the value in hexadecimal:
.IP
.nf
\f[C]
\ \ #\\x1f42d;
\f[]
.fi
.PP
In all these forms, the case of the indicating letter is not
significant, i.e.
\f[C]#b1010\f[] and \f[C]#B1010\f[] are identical as are
\f[C]#16rf00\f[] and \f[C]#16Rf00\f[].
.PP
Similarly, the case is not significant for digits beyond 9 (i.e.
\[aq]a\[aq], \[aq]b\[aq], \[aq]c\[aq], \&... for number bases larger
than 10), e.g.
\f[C]#xabcd\f[] is the same as \f[C]#xABCD\f[] and can even be mixed in
the same number, e.g.
\f[C]#36rHelloWorld\f[] is valid and the same number as
\f[C]#36Rhelloworld\f[] and \f[C]#36rHELLOWORLD\f[].
.PP
The character notation using hexadecimal code representation
(\f[C]#\\x....;\f[]) is basically the same thing as the regular
hexadecimal notation \f[C]#x...\f[] except that it conveys to the reader
that a character is intended and that it does a sanity check on the
value (e.g.
negative numbers and value outside the Unicode range are not permitted).
.SS Floating point numbers
.PP
There is only one type of floating point numbers and the literals are
written in the usual way, e.g.
these are all valid floating point numbers:
.IP
.nf
\f[C]
1.0\ +1.0\ \-1.0\ 1.0e10\ 1.111e\-10
\f[]
.fi
.PP
The one thing to watch out for is that you cannot omit the the part
before or after the decimal point if it is zero.
E.g.
the following are not valid forms: \f[C]100.\f[] or \f[C]\&.125\f[].
.SS Strings
.PP
There are two forms of strings: list strings and binary strings.
.SS List Strings
.PP
List strings are just lists of integers (where the values have to be
from a certain set of numbers that are considered valid characters) but
they have their own syntax for literals (which will also be used for
integer lists as an output representation if the list contents looks
like it is meant to be a string): "any text between double quotes where
" and other special characters like \f[C]\\n\f[] can be escaped".
.PP
As a special case you can also write out the character number in the
form \f[C]\\xHHH;\f[] (where "HHH" is an integer in hexadecimal
notation), e.g.
\f[C]"\\x61;\\x62;\\x63;"\f[] is a complicated way of writing
\f[C]"abc"\f[].
This can be convenient when writing Unicode letters not easily typeable
or viewable with regular fonts.
E.g.
\f[C]"Cat:\ \\\\x1f639;"\f[] might be easier to type (and view on output
devices without a Unicode font) then typing the actual unicode letter.
.SS Binary Strings
.PP
Binary strings are just like list strings but they are represented
differently in the virtual machine.
The simple syntax is \f[C]#"..."\f[], e.g.
\f[C]#"This\ is\ a\ binary\ string\ \\n\ with\ some\ \\"escaped\\"\ and\ quoted\ (\\\\x1f639;)\ characters"\f[]
.PP
You can also use the general format for creating binaries
(\f[C]#B(...)\f[], described below), e.g.
\f[C]#B("a")\f[], \f[C]#"a"\f[], and \f[C]#B(97)\f[] are all the same
binary string.
.SS Character Escaping
.PP
Certain control characters can be more readably included by using their
escaped name:
.IP
.nf
\f[C]
\ \ |\ Escaped\ name\ |\ Character\ \ \ \ \ \ \ |
\ \ |\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\ \ |\ \\b\ \ \ \ \ \ \ \ \ \ \ |\ Backspace\ \ \ \ \ \ \ |
\ \ |\ \\t\ \ \ \ \ \ \ \ \ \ \ |\ Tab\ \ \ \ \ \ \ \ \ \ \ \ \ |
\ \ |\ \\n\ \ \ \ \ \ \ \ \ \ \ |\ Newline\ \ \ \ \ \ \ \ \ |
\ \ |\ \\v\ \ \ \ \ \ \ \ \ \ \ |\ Vertical\ tab\ \ \ \ |
\ \ |\ \\f\ \ \ \ \ \ \ \ \ \ \ |\ Form\ Feed\ \ \ \ \ \ \ |
\ \ |\ \\r\ \ \ \ \ \ \ \ \ \ \ |\ Carriage\ Return\ |
\ \ |\ \\e\ \ \ \ \ \ \ \ \ \ \ |\ Escape\ \ \ \ \ \ \ \ \ \ |
\ \ |\ \\s\ \ \ \ \ \ \ \ \ \ \ |\ Space\ \ \ \ \ \ \ \ \ \ \ |
\ \ |\ \\d\ \ \ \ \ \ \ \ \ \ \ |\ Delete\ \ \ \ \ \ \ \ \ \ |
\f[]
.fi
.PP
Alternatively you can also use the hexadecimal character encoding, e.g.
\f[C]"a\\nb"\f[] and \f[C]"a\\x0a;b"\f[] are the same string.
.SS Binaries
.PP
We have already seen binary strings, but the \f[C]#B(...)\f[] syntax can
be used to create binaries with any contents.
Unless the contents is a simple integer you need to annotate it with a
type and/or size.
.PP
Example invocations are that show the various annotations:
.IP
.nf
\f[C]
>\ #B(42\ (42\ (size\ 16))\ (42\ (size\ 32)))
#B(42\ 0\ 42\ 0\ 0\ 0\ 42)
>\ #B(\-42\ 111\ (\-42\ (size\ 16))\ 111\ (\-42\ (size\ 32)))
#B(\-42\ 111\ (\-42\ (size\ 16))\ 111\ (\-42\ (size\ 32)))
>\ #B((42\ (size\ 32)\ big\-endian)\ (42\ (size\ 32)\ little\-endian))
#B(0\ 0\ 0\ 42\ 42\ 0\ 0\ 0)
>\ #B((1.23\ float)\ (1.23\ (size\ 32)\ float)\ (1.23\ (size\ 64)\ float))
#B(63\ 243\ 174\ 20\ 122\ 225\ 71\ 174\ 63\ 157\ 112\ 164\ 63\ 243\ 174\ 20
\ \ \ 122\ 225\ 71\ 174)
>\ #B((#"a"\ binary)\ (#"b"\ binary))
#"ab"
\f[]
.fi
.PP
Learn more about "segments" of binary data e.g.
in "Learn You Some
Erlang (http://learnyousomeerlang.com/starting-out-for-real#bit-syntax)"
<http://learnyousomeerlang.com/starting-out-for-real#bit-syntax>.
.SS Lists
.PP
Lists are formed either as \f[C](\ ...\ )\f[] or \f[C][\ ...\ ]\f[]
where the optional elements of the list are separated by some form or
whitespace.
For example:
.IP
.nf
\f[C]
()
(the\ empty\ list)
(foo\ bar\ baz)
(foo
\ bar
\ baz)
\f[]
.fi
.SS Tuples
.PP
Tuples are written as \f[C]#(value1\ value2\ ...)\f[].
The empty tuple \f[C]#()\f[] is also valid.
.SS Maps
.PP
Maps are written as \f[C]#M(key1\ value1\ key2\ value2\ ...)\f[] The
empty map is also valid and written as \f[C]#M()\f[].
.SS Symbols
.PP
Things that cannot be parsed as any of the above are usually considered
as a symbol.
.PP
Simple examples are \f[C]foo\f[], \f[C]Foo\f[], \f[C]foo\-bar\f[],
\f[C]:foo\f[].
But also somewhat surprisingly \f[C]123foo\f[] and \f[C]1.23e4extra\f[]
(but note that illegal digits don\[aq]t make a number a symbol when
using the explicit number base notation, e.g.
\f[C]#b10foo\f[] gives an error).
.PP
Symbol names can contain a surprising breadth or characters, basically
all of the latin\-1 character set without control character, whitespace,
the various brackets, double quotes and semicolon.
.PP
Of these, only \f[C]|\f[], \f[C]\\\[aq]\f[], \f[C]\[aq]\f[], \f[C],\f[],
and \f[C]#\f[] may not be the first character of the symbol\[aq]s name
(but they \f[I]are\f[] allowed as subsequent letters).
.PP
I.e.
these are all legal symbols: \f[C]foo\f[], \f[C]foo\f[], \f[C]µ#\f[],
\f[C]±1\f[], \f[C]451°F\f[].
.PP
Symbols can be explicitly constructed by wrapping their name in vertical
bars, e.g.
\f[C]|foo|\f[], \f[C]|symbol\ name\ with\ spaces|\f[].
In this case the name can contain any character of in the range from 0
to 255 (or even none, i.e.
\f[C]||\f[] is a valid symbol).
The vertical bar in the symbol name needs to be escaped:
\f[C]|symbol\ with\ a\ vertical\ bar\ \\|\ in\ its\ name|\f[] (similarly
you will obviously have to escape the escape character as well).
.SS Comments
.PP
Comments come in two forms: line comments and block comments.
.PP
Line comments start with a semicolon (\f[C];\f[]) and finish with the
end of the line.
.PP
Block comments are written as \f[C]#|\ comment\ text\ |#\f[] where the
comment text may span multiple lines but my not contain another block
comment, i.e.
it may not contain the character sequence \f[C]#|\f[].
.SS Evaluation While Reading
.PP
\f[C]#.(...\ some\ expression\ ...)\f[].
E.g.
\f[C]#.(+\ 1\ 1)\f[] will evaluate the \f[C](+\ 1\ 1)\f[] while it reads
the expression and then be effectively \f[C]2\f[].
.SH Supported forms
.SS Core forms
.IP
.nf
\f[C]
(quote\ e)
(cons\ head\ tail)
(car\ e)
(cdr\ e)
(list\ e\ ...\ )
(tuple\ e\ ...\ )
(tref\ tuple\ index)
(tset\ tuple\ index\ val)
(binary\ seg\ ...\ )
(map\ key\ val\ ...)
(map\-get\ m\ k)\ (map\-set\ m\ k\ v\ ...)\ (map\-update\ m\ k\ v\ ...)
(lambda\ (arg\ ...)\ ...)
(match\-lambda
\ \ ((arg\ ...\ )\ {{(when\ e\ ...)}}\ ...)\ \ \ \ \ \ \ \ \ \ \ \-\ Matches\ clauses
\ \ ...\ )
(function\ func\-name\ arity)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \-\ Function\ references
(function\ mod\-name\ func\-name\ arity)
(let\ ((pat\ {{(when\ e\ ...)}}\ e)
\ \ \ \ \ \ ...)
\ \ ...\ )
(let\-function\ ((name\ lambda|match\-lambda)\ \ \ \ \ \-\ Local\ functions
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ...\ )
\ \ ...\ )
(letrec\-function\ ((name\ lambda|match\-lambda)\ \ \-\ Local\ functions
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ...\ )
\ \ ...\ )
(let\-macro\ ((name\ lambda\-match\-lambda)\ \ \ \ \ \ \ \ \-\ Local\ macros
\ \ \ \ \ \ \ \ \ \ \ \ ...)
\ \ ...)
(progn\ ...\ )
(if\ test\ true\-expr\ {{false\-expr}})
(case\ e
\ \ (pat\ {{(when\ e\ ...)}}\ ...)
\ \ ...\ ))
(receive
\ \ (pat\ {{(when\ e\ ...)}}\ ...\ )
\ \ ...
\ \ (after\ timeout\ ...\ ))
(catch\ ...\ )
(try
\ \ e
\ \ {{(case\ ((pat\ {{(when\ e\ ...)}}\ ...\ )
\ \ \ \ \ \ \ \ \ \ ...\ ))}}
\ \ {{(catch
\ \ \ \ \ (((tuple\ type\ value\ ignore)\ {{(when\ e\ ...)}}
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \-\ Must\ be\ tuple\ of\ length\ 3!
\ \ \ \ \ \ ...\ )
\ \ \ \ \ ...\ )}}
\ \ {{(after\ ...\ )}})
(funcall\ func\ arg\ ...\ )
(call\ mod\ func\ arg\ ...\ )\ \ \ \ \ \ \ \ \-\ Call\ to\ Mod:Func(Arg,\ ...\ )

(define\-module\ name\ meta\-data\ attributes)
(extend\-module\ meta\-data\ attributes)

(define\-function\ name\ meta\-data\ lambda|match\-lambda)
(define\-macro\ name\ meta\-data\ lambda|match\-lambda)
\f[]
.fi
.SS Basic macro forms
.IP
.nf
\f[C]
(:\ mod\ func\ arg\ ...\ )\ =>
\ \ \ \ \ \ \ \ (call\ \[aq]mod\ \[aq]func\ arg\ ...\ )
(mod:func\ arg\ ...\ )\ =>
\ \ \ \ \ \ \ \ (call\ \[aq]mod\ \[aq]func\ arg\ ...\ )
(?\ {{timeout\ {{default}}\ }})
(++\ ...\ )
(list*\ ...)
(let*\ (...)\ ...\ )
(flet\ ((name\ (arg\ ...)\ {{doc\-string}}\ ...)
\ \ \ \ \ \ \ ...)
\ \ ...)
(flet*\ (...)\ ...\ )
(fletrec\ ((name\ (arg\ ...)\ {{doc\-string}}\ ...)
\ \ \ \ \ \ \ \ \ \ ...)
\ \ ...)
(cond\ ...
\ \ \ \ \ \ {{(?=\ pat\ expr)}}
\ \ \ \ \ \ ...\ )
(andalso\ ...\ )
(orelse\ ...\ )
(fun\ func\ arity)
(fun\ mod\ func\ arity)
(lc\ (qual\ ...)\ ...)
(list\-comp\ (qual\ ...)\ ...)
(bc\ (qual\ ...)\ ...)
(binary\-comp\ (qual\ ...)\ ...)
(match\-spec\ ...)
\f[]
.fi
.SS Common Lisp inspired macros
.IP
.nf
\f[C]
(defun\ name\ (arg\ ...)\ {{doc\-string}}\ ...)
(defun\ name
\ \ {{doc\-string}}
\ \ ((argpat\ ...)\ ...)
\ \ ...)
(defmacro\ name\ (arg\ ...)\ {{doc\-string}}\ ...)
(defmacro\ name\ arg\ {{doc\-string}}\ ...)
(defmacro\ name
\ \ {{doc\-string}}
\ \ ((argpat\ ...)\ ...)
\ \ ...)
(defsyntax\ name
\ \ (pat\ exp)
\ \ ...)
(macrolet\ ((name\ (arg\ ...)\ {{doc\-string}}\ ...)
\ \ \ \ \ \ \ \ \ \ \ ...)
\ \ ...)
(syntaxlet\ ((name\ (pat\ exp)\ ...)
\ \ \ \ \ \ \ \ \ \ \ \ ...)
\ \ ...)
(prog1\ ...)
(prog2\ ...)
(defmodule\ name\ ...)
(defrecord\ name\ ...)
\f[]
.fi
.SS Older Scheme inspired macros
.IP
.nf
\f[C]
(define\ (name\ arg\ ...)\ ...)
(define\ name\ lambda|match\-lambda)
(define\-syntax\ name
\ \ (syntax\-rules\ (pat\ exp)\ ...)|(macro\ (pat\ body)\ ...))
(let\-syntax\ ((name\ ...)
\ \ \ \ \ \ \ \ \ \ \ \ \ ...)
\ \ ...)
(begin\ ...)
(define\-record\ name\ ...)
\f[]
.fi
.SH Patterns
.PP
Written as normal data expressions where symbols are variables and use
quote to match explicit values.
Binaries and tuples have special syntax.
.IP
.nf
\f[C]
{ok,X}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \->\ (tuple\ \[aq]ok\ x)
error\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \->\ \[aq]error
{yes,[X|Xs]}\ \ \ \ \ \ \ \ \ \ \ \ \->\ (tuple\ \[aq]yes\ (cons\ x\ xs))
<<34,U:16,F/float>>\ \ \ \ \ \->\ (binary\ 34\ (u\ (size\ 16))\ (f\ float))
[P|Ps]=All\ \ \ \ \ \ \ \ \ \ \ \ \ \ \->\ (=\ (cons\ p\ ps)\ all)
\f[]
.fi
.PP
Repeated variables are supported in patterns and there is an automatic
comparison of values.
.PP
\f[C]_\f[] as the "don\[aq]t care" variable is supported.
This means that the symbol \f[C]_\f[], which is a perfectly valid
symbol, can never be bound through pattern matching.
.PP
Aliases are defined with the \f[C](=\ pattern1\ pattern2)\f[] pattern.
As in Erlang patterns they can be used anywhere in a pattern.
.PP
\f[I]CAVEAT\f[] The lint pass of the compiler checks for aliases and if
they are possible to match.
If not an error is flagged.
This is not the best way.
Instead there should be a warning and the offending clause removed, but
later passes of the compiler can\[aq]t handle this yet.
.SH Guards
.PP
Wherever a pattern occurs (in let, case, receive, lc, etc.) it can be
followed by an optional guard which has the form (when test ...).
Guard tests are the same as in vanilla Erlang and can contain the
following guard expressions:
.IP
.nf
\f[C]
(quote\ e)
(cons\ gexpr\ gexpr)
(car\ gexpr)
(cdr\ gexpr)
(list\ gexpr\ ...)
(tuple\ gexpr\ ...)
(tref\ gexpr\ gexpr)
(binary\ ...)
(progn\ gtest\ ...)\ \ \ \ \ \ \ \ \ \ \ \-\ Sequence\ of\ guard\ tests
(if\ gexpr\ gexpr\ gexpr)
(type\-test\ e)
(guard\-bif\ ...)\ \ \ \ \ \ \ \ \ \ \ \ \ \-\ Guard\ BIFs,\ arithmetic,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ boolean\ and\ comparison\ operators
\f[]
.fi
.PP
An empty guard, \f[C](when)\f[], always succeeds as there is no test
which fails.
This simplifies writing macros which handle guards.
.SH Comments in Function Definitions
.PP
Inside functions defined with defun LFE permits optional comment strings
in the Common Lisp style after the argument list.
So we can have:
.IP
.nf
\f[C]
(defun\ max\ (x\ y)
\ \ "The\ max\ function."
\ \ (if\ (>=\ x\ y)\ x\ y))
\f[]
.fi
.PP
Optional comments are also allowed in match style functions after the
function name and before the clauses:
.IP
.nf
\f[C]
(defun\ max
\ \ "The\ max\ function."
\ \ ((x\ y)\ (when\ (>=\ x\ y))\ x)
\ \ ((x\ y)\ y))
\f[]
.fi
.PP
This is also possible in a similar style in local functions defined by
flet and fletrec:
.IP
.nf
\f[C]
(defun\ foo\ (x\ y)
\ \ "The\ max\ function."
\ \ (flet\ ((m\ (a\ b)
\ \ \ \ \ \ \ \ \ \ \ "Local\ comment."
\ \ \ \ \ \ \ \ \ \ \ (if\ (>=\ a\ b)\ a\ b)))
\ \ \ \ (m\ x\ y)))
\f[]
.fi
.SH Variable Binding and Scoping
.PP
Variables are lexically scoped and bound by \f[C]lambda\f[],
\f[C]match\-lambda\f[] and \f[C]let\f[] forms.
All variables which are bound within these forms shadow variables bound
outside but other variables occurring in the bodies of these forms will
be imported from the surrounding environments.No variables are exported
out of the form.
So for example the following function:
.IP
.nf
\f[C]
(defun\ foo\ (x\ y\ z)
\ \ (let\ ((x\ (zip\ y)))
\ \ \ \ (zap\ x\ z))
\ \ (zop\ x\ y))
\f[]
.fi
.PP
The variable \f[C]y\f[] in the call \f[C](zip\ y)\f[] comes from the
function arguments.
However, the \f[C]x\f[] bound in the \f[C]let\f[] will shadow the
\f[C]x\f[] from the arguments so in the call \f[C](zap\ x\ z)\f[] the
\f[C]x\f[] is bound in the \f[C]let\f[] while the \f[C]z\f[] comes from
the function arguments.
In the final \f[C](zop\ x\ y)\f[] both \f[C]x\f[] and \f[C]y\f[] come
from the function arguments as the \f[C]let\f[] does not export
\f[C]x\f[].
.SH Function Binding and Scoping
.PP
Functions are lexically scoped and bound by the top\-level
\f[C]defun\f[] and by the macros \f[C]flet\f[] and \f[C]fletrec\f[].
LFE is a Lisp\-2 so functions and variables have separate namespaces and
when searching for function both name and arity are used.
This means that when calling a function which has been bound to a
variable using \f[C](funcall\ func\-var\ arg\ ...)\f[] is required to
call \f[C]lambda\f[]/\f[C]match\-lambda\f[] bound to a variable or used
as a value.
.PP
Unqualified functions shadow as stated above which results in the
following order within a module, outermost to innermost:
.IP \[bu] 2
Predefined Erlang BIFs
.IP \[bu] 2
Predefined LFE BIFs
.IP \[bu] 2
Imports
.IP \[bu] 2
Top\-level defines
.IP \[bu] 2
Flet/fletrec
.IP \[bu] 2
Core forms, these can never be shadowed
.PP
This means that it is perfectly legal to shadow BIFs by imports,
BIFs/imports by top\-level functions and BIFs/imports/top\-level by
\f[C]fletrec\f[]s.
In this respect there is nothing special about BIfs, they just behave as
prefined imported functions, a whopping big
\f[C](import\ (from\ erlang\ ...))\f[].
EXCEPT that we know about guard BIFs and expression BIFs.
If you want a private version of \f[C]spawn\f[] then define it, there
will be no warnings.
.PP
\f[I]CAVEAT\f[] This does not hold for the supported core forms.
These can be shadowed by imports or redefined but the compiler will
\f[I]always\f[] use the core meaning and never an alternative.
Silently!
.SH Module definition
.IP
.nf
\f[C]
(defmodule\ name
\ \ "This\ is\ the\ module\ documentation."
\ \ (export\ (f\ 2)\ (g\ 1)\ ...\ )
\ \ (export\ all)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;Export\ all\ functions
\ \ (import\ (from\ mod\ (f1\ 2)\ (f2\ 1)\ ...\ )
\ \ \ \ \ \ \ \ \ \ (rename\ mod\ ((f1\ 2)\ sune)\ ((f2\ 1)\ kurt)\ ...\ ))
\ \ (import\ (prefix\ mod\ mod\-prefix))\ \ \ \ \ \ \-\ NYI
\ \ (attr\-1\ value\-1\ value\-2)
\ \ ...\ )
\f[]
.fi
.PP
Can have multiple export and import declarations within module
declaration.
The \f[C](export\ all)\f[] declaration is allowed together with other
export declarations and overrides them.
Other attributes which are not recognised by the compiler are allowed
and are simply passed on to the module and can be accessed through
\f[C]module_info/0\-1\f[].
.SH Parameterized modules
.IP
.nf
\f[C]
(defmodule\ (name\ par1\ par2\ ...\ )
\ \ ...\ )
\f[]
.fi
.PP
Define a parameterized module which behaves the same way as in vanilla
Erlang.
For now avoid defining functions \[aq]new\[aq] and \[aq]instance\[aq].
.SH Macros
.PP
Macro calls are expanded in both body and patterns.
This can be very useful to have both make and match macros, but be
careful with names.
.PP
A macro is function of two argument which is a called with a list of the
arguments to the macro call and the current macro environment.
It can be either a lambda or a match\-lambda.
The basic forms for defining macros are:
.IP
.nf
\f[C]
(define\-macro\ name\ meta\-data\ lambda|match\-lambda)
(let\-macro\ ((name\ lambda|match\-lambda)
\ \ ...)
\f[]
.fi
.PP
Macros are definitely NOT hygienic in any form.
.PP
To simplify writing macros there are a number of predefined macros:
.IP
.nf
\f[C]
(defmacro\ name\ (arg\ ...)\ ...)
(defmacro\ name\ arg\ ...)
(defmacro\ name\ ((argpat\ ...)\ body)\ ...)
\f[]
.fi
.PP
Defmacro can be used for defining simple macros or sequences of matches
depending on whether the arguments are a simple list of symbols or can
be interpreted as a list of pattern/body pairs.
In the second case when the argument is just a symbol it will be bound
to the whole argument list.
For example:
.IP
.nf
\f[C]
(defmacro\ double\ (a)\ `(+\ ,a\ ,a))
(defmacro\ my\-list\ args\ `(list\ ,\@args))
(defmacro\ andalso
\ \ ((list\ e)\ `,e)
\ \ ((cons\ e\ es)\ `(if\ ,e\ (andalso\ ,\@es)\ \[aq]false))
\ \ (()\ `\[aq]true))
\f[]
.fi
.PP
The macro definitions in a macrolet obey the same rules as defmacro.
.PP
The macro functions created by defmacro and macrolet automatically add
the second argument with the current macro environment with the name
$ENV.
This allows explicit expansion of macros inside the macro and also
manipulation of the macro environment.
No changes to the environment are exported outside the macro.
.PP
User defined macros shadow the predefined macros so it is possible to
redefine the built\-in macro definitions.
However, see the caveat below!
.PP
Yes, we have the backquote.
It is implemented as a macro so it is expanded at macro expansion time.
.PP
Local functions that are only available at compile time and can be
called by macros are defined using eval\-when\-compile:
.IP
.nf
\f[C]
(defmacro\ foo\ (x)
\ \ ...
\ \ (foo\-helper\ m\ n)
\ \ ...)

(eval\-when\-compile
\ \ (defun\ foo\-helper\ (a\ b)
\ \ \ \ ...)

\ \ )
\f[]
.fi
.PP
There can be many eval\-when\-compile forms.
Functions defined within an \f[C]eval\-when\-compile\f[] are mutually
recursive but they can only call other local functions defined in an
earlier \f[C]eval\-when\-compile\f[] and macros defined earlier in the
file.
Functions defined in \f[C]eval\-when\-compile\f[] which are called by
macros can defined after the macro but must be defined before the macro
is used.
.PP
Scheme\[aq]s syntax rules are an easy way to define macros where the
body is just a simple expansion.
These are supported with \f[C]defsyntax\f[] and \f[C]syntaxlet\f[].
Note that the patterns are only the arguments to the macro call and do
not contain the macro name.
So using them we would get:
.IP
.nf
\f[C]
(defsyntax\ andalso
\ \ (()\ \[aq]true)
\ \ ((e)\ e)
\ \ ((e\ .\ es)\ (case\ e\ (\[aq]true\ (andalso\ .\ es))\ (\[aq]false\ \[aq]false))))
\f[]
.fi
.PP
N.B.
These are definitely NOT hygienic.
.PP
\f[I]CAVEAT\f[] While it is perfectly legal to define a Core form as a
macro these will silently be ignored by the compiler.
.SH Comments in Macro Definitions
.PP
Inside macros defined with defmacro LFE permits optional comment strings
in the Common Lisp style after the argument list.
So we can have:
.IP
.nf
\f[C]
(defmacro\ double\ (a)
\ \ "Double\ macro."
\ \ `(+\ ,a\ ,a))
\f[]
.fi
.PP
Optional comments are also allowed in match style macros after the macro
name and before the clauses:
.IP
.nf
\f[C]
(defmacro\ my\-list\ args
\ \ "List\ of\ arguments."
\ \ `(list\ ,\@args))

(defmacro\ andalso
\ \ "The\ andalso\ form."
\ \ ((list\ e)\ `,e)
\ \ ((cons\ e\ es)\ `(if\ ,e\ (andalso\ ,\@es)\ \[aq]false))
\ \ (()\ `\[aq]true))
\f[]
.fi
.PP
This is also possible in a similar style in local functions defined by
macrolet:
.IP
.nf
\f[C]
(defun\ foo\ (x\ y)
\ \ "The\ max\ function."
\ \ (macrolet\ ((m\ (a\ b)
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "Poor\ macro\ definition."
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ `(if\ (>=\ ,a\ ,b)\ ,a\ ,b)))
\ \ \ \ (m\ x\ y)))
\f[]
.fi
.SH Extended cond
.PP
Cond has been extended with the extra test (?= pat expr) which tests if
the result of expr matches pat.
If so it binds the variables in pat which can be used in the cond.
A optional guard is allowed here.
An example:
.IP
.nf
\f[C]
(cond\ ((foo\ x)\ ...)
\ \ \ \ \ \ ((?=\ (cons\ x\ xs)\ (when\ (is_atom\ x))\ (bar\ y))
\ \ \ \ \ \ \ (fubar\ xs\ (baz\ x)))
\ \ \ \ \ \ ((?=\ (tuple\ \[aq]ok\ x)\ (baz\ y))
\ \ \ \ \ \ \ (zipit\ x))
\ \ \ \ \ \ ...\ )
\f[]
.fi
.SH Records
.PP
Records are tuples with the record name as first element and the rest of
the fields in order exactly like "normal" Erlang records.
As with Erlang records the default default value is \[aq]undefined\[aq].
.IP
.nf
\f[C]
(defrecord\ name
\ \ field
\ \ (field\ default\-value)
\ \ ...\ )
\f[]
.fi
.PP
Will create access functions/macros for creation and accessing fields.
The \f[C]make\-\f[], \f[C]match\-\f[] and \f[C]set\-\f[] forms takes
optional argument pairs field\-name value to get non\-default values.
E.g.
for
.IP
.nf
\f[C]
(defrecord\ person
\ \ (name\ "")
\ \ (address\ "")
\ \ age)
\f[]
.fi
.PP
the following will be generated:
.IP
.nf
\f[C]
(make\-person\ {{field\ value}}\ ...\ )
(match\-person\ {{field\ value}}\ ...\ )
(is\-person\ r)
(fields\-person)
(emp\-person\ {{field\ value}}\ ...\ )
(set\-person\ r\ {{field\ value}}\ ...\ )
(person\-name\ r)
(person\-name)
(set\-person\-name\ r\ name)
(person\-age\ r)
(person\-age)
(set\-person\-age\ r\ age)
(person\-address\ r)
(set\-person\-address\ r\ address)
\f[]
.fi
.IP \[bu] 2
\f[C](make\-person\ name\ "Robert"\ age\ 54)\f[] \- Will create a new
person record with the name field set to "Robert", the age field set to
54 and the address field set to the default "".
.IP \[bu] 2
\f[C](match\-person\ name\ name\ age\ 55)\f[] \- Will match a person
with age 55 and bind the variable name to the name field of the record.
Can use any variable name here.
.IP \[bu] 2
\f[C](is\-person\ john)\f[] \- Test if john is a person record.
.IP \[bu] 2
\f[C](emp\-person\ age\ \[aq]$1)\f[] \- Create an Ets Match Pattern for
record person where the age field is set to $1 and all other fields are
set to \[aq]_.
.IP \[bu] 2
\f[C](person\-address\ john)\f[] \- Return the address field of the
person record john.
.IP \[bu] 2
\f[C](person\-address)\f[] \- Return the index of the address field of a
person record.
.IP \[bu] 2
\f[C](set\-person\-address\ john\ "back\ street")\f[] \- Sets the
address field of the person record john to "back street".
.IP \[bu] 2
\f[C](set\-person\ john\ age\ 35\ address\ "front\ street")\f[] \- In
the person record john set the age field to 35 and the address field to
"front street".
.IP \[bu] 2
\f[C](fields\-person)\f[] \- Returns a list of fields for the record.
This is useful for when using LFE with Mnesia, as the record field names
don\[aq]t have to be provided manually in the create_table call.
.IP \[bu] 2
\f[C](size\-person)\f[] \- Returns the size of the record tuple.
.SH Binaries/bitstrings
.PP
A binary is
.IP
.nf
\f[C]
(binary\ seg\ ...\ )
\f[]
.fi
.PP
where \f[C]seg\f[] is
.IP
.nf
\f[C]
\ \ \ \ \ \ \ \ byte
\ \ \ \ \ \ \ \ string
\ \ \ \ \ \ \ \ (val\ integer|float|binary|bitstring|bytes|bits
\ \ \ \ \ \ \ \ \ \ \ \ \ (size\ n)\ (unit\ n)
\ \ \ \ \ \ \ \ \ \ \ \ \ big\-endian|little\-endian|native\-endian
\ \ \ \ \ \ \ \ \ \ \ \ \ big|little|native
\ \ \ \ \ \ \ \ \ \ \ \ \ signed|unsigned)
\f[]
.fi
.PP
\f[C]val\f[] can also be a string in which case the specifiers will be
applied to every character in the string.
As strings are just lists of integers these are also valid here.
In a binary constant all literal forms are allowed on input but they
will always be written as bytes.
.SH Maps
.PP
A map is:
.IP
.nf
\f[C]
(map\ key\ value\ ...\ )
\f[]
.fi
.PP
To access maps there are the following forms:
.IP \[bu] 2
\f[C](map\-get\ map\ key)\f[] \- Return the value associated with key in
map.
.IP \[bu] 2
\f[C](map\-set\ map\ key\ val\ ...\ )\f[] \- Set keys in map to values.
.IP \[bu] 2
\f[C](map\-update\ map\ key\ val\ ...\ )\f[] \- Update keys in map to
values.
Note that this form requires all the keys to exist.
.PP
N.B.
This syntax for processing maps has stablized but may change in the
future!
.PP
There is also an alternate short form \f[C]map\f[], \f[C]mref\f[],
\f[C]mset\f[], \f[C]mupd\f[] based on the Maclisp array reference forms.
They take the same arguments as their longer alternatives.
.SH List/binary comprehensions
.PP
List/binary comprehensions are supported as macros.
The syntax for list comprehensions is:
.IP
.nf
\f[C]
(lc\ (qual\ \ ...)\ expr\ ...\ )
(list\-comp\ (qual\ \ ...)\ expr\ ...\ )
\f[]
.fi
.PP
where the final expr is used to generate the elements of the list.
.PP
The syntax for binary comprehensions is:
.IP
.nf
\f[C]
(bc\ (qual\ \ ...)\ expr\ ...\ )
(binary\-comp\ (qual\ \ ...)\ expr\ ...\ )
\f[]
.fi
.PP
where the final expr is a bitseg expr and is used to generate the
elements of the binary.
.PP
The supported qualifiers, in both list/binary comprehensions are:
.IP
.nf
\f[C]
(<\-\ pat\ {{guard}}\ list\-expr)\ \ \ \ \ \ \ \ \-\ Extract\ elements\ from\ list
(<=\ bin\-pat\ {{guard}}\ binary\-expr)\ \ \-\ Extract\ elements\ from\ binary
(?=\ pat\ {{guard}}\ expr)\ \ \-\ Match\ test\ and\ bind\ variables\ in\ pat
expr\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \-\ Normal\ boolean\ test
\f[]
.fi
.PP
Some examples:
.IP
.nf
\f[C]
(lc\ ((<\-\ v\ (when\ (>\ v\ 5))\ l1)
\ \ \ \ \ (==\ (rem\ v\ 2)\ 0))
\ \ v)
\f[]
.fi
.PP
returns a list of all the even elements of the list \f[C]l1\f[] which
are greater than 5.
.IP
.nf
\f[C]
(bc\ ((<=\ (f\ float\ (size\ 32))\ b1)\ \ \ \ \ \ \ \ ;Only\ bitseg\ needed
\ \ \ \ \ (>\ f\ 10.0))
\ \ (:\ io\ fwrite\ "~p\\n"\ (list\ f))
\ \ (f\ float\ (size\ 64)))\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;Only\ bitseg\ needed
\f[]
.fi
.PP
returns a binary of floats of size 64 of floats which are larger than
10.0 from the binary b1 and of size 32.
The returned numbers are first printed.
.PP
N.B.
A word of warning when using guards when extracting elements from a
binary.
When a match/guard fails for a binary no more attempts will be made to
extract data from the binary.
This means that even if a value could be extracted from the binary if
the guard fails this value will be lost and extraction will cease.
This is \f[I]NOT\f[] the same as having following boolean test which may
remove an element but will not stop extraction.
Using a guard is probably not what you want!
.PP
Normal vanilla Erlang does the same thing but does not allow guards.
.SH ETS and Mnesia
.PP
Apart from \f[C](emp\-record\ ...)\f[] macros for ETS Match Patterns,
which are also valid in Mnesia, LFE also supports match specifications
and Query List Comprehensions.
The syntax for a match specification is the same as for match\-lambdas:
.IP
.nf
\f[C]
(match\-spec
\ \ ((arg\ ...\ )\ {{(when\ e\ ...)}}\ ...)\ \ \ \ \ \ \ \ \ \ \ \ \ \-\ Matches\ clauses
\ \ ...\ )
\f[]
.fi
.PP
For example:
.IP
.nf
\f[C]
(ets:select\ db\ (match\-spec
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ([(tuple\ _\ a\ b)]\ (when\ (>\ a\ 3))\ (tuple\ \[aq]ok\ b))))
\f[]
.fi
.PP
It is a macro which creates the match specification structure which is
used in \f[C]ets:select\f[] and \f[C]mnesia:select\f[].
The same \f[C]match\-spec\f[] macro can also be used with the dbg
module.
The same restrictions as to what can be done apply as for vanilla match
specifications:
.IP \[bu] 2
There is only a limited number of BIFs which are allowed
.IP \[bu] 2
There are some special functions only for use with dbg
.IP \[bu] 2
For ets/mnesia it takes a single parameter which must a tuple or a
variable
.IP \[bu] 2
For dbg it takes a single parameter which must a list or a variable
.PP
N.B.
the current macro neither knows nor cares whether it is being used in
ets/mnesia or in dbg.
It is up to the user to get this right.
.PP
Macros, especially record macros, can freely be used inside match specs.
.PP
\f[I]CAVEAT\f[] Some things which are known not to work in the current
version are andalso, orelse and record updates.
.SH Query List Comprehensions
.PP
LFE supports QLCs for mnesia through the qlc macro.
It has the same structure as a list comprehension and generates a Query
Handle in the same way as with \f[C]qlc:q([...])\f[].
The handle can be used together with all the combination functions in
the module qlc.
.PP
For example:
.IP
.nf
\f[C]
(qlc\ (lc\ ((<\-\ (tuple\ k\ v)\ (:\ ets\ table\ e2))\ (==\ k\ i))\ v)
\ \ \ \ \ {{Option}})
\f[]
.fi
.PP
Macros, especially record macros, can freely be used inside query list
comprehensions.
.PP
\f[I]CAVEAT\f[] Some things which are known not to work in the current
version are nested QLCs and let/case/recieve which shadow variables.
.SH Predefined LFE functions
.PP
The following more or less standard lisp functions are predefined:
.IP
.nf
\f[C]
(<arith_op>\ expr\ ...)
(<comp_op>\ expr\ ...)
\f[]
.fi
.PP
The standard arithmentic operators, + \- * /, and comparison operators,
> >= < =< == /= =:= =/= , can take multiple arguments the same as their
standard lisp counterparts.
This is still experimental and implemented using macros.
They do, however, behave like normal functions and evaluate ALL their
arguments before doing the arithmetic/comparisons operations.
.IP
.nf
\f[C]
(acons\ key\ value\ list)
(pairlis\ keys\ values\ {{list}})
(assoc\ key\ list)
(assoc\-if\ test\ list)
(assoc\-if\-not\ test\ list)
(rassoc\ value\ list)
(rassoc\-if\ test\ list)
(rassoc\-if\-not\ test\ list)
\f[]
.fi
.PP
The standard association list functions.
.IP
.nf
\f[C]
(subst\ new\ old\ tree)
(subst\-if\ new\ test\ tree)
(subst\-if\-not\ new\ test\ tree)
(sublis\ alist\ tree)
\f[]
.fi
.PP
The standard substituition functions.
.IP
.nf
\f[C]
(macroexpand\-1\ expr\ {{environment}})
\f[]
.fi
.PP
If Expr is a macro call, does one round of expansion, otherwise returns
Expr.
.IP
.nf
\f[C]
(macroexpand\ expr\ {{environment}})
\f[]
.fi
.PP
Returns the expansion returned by calling macroexpand\-1 repeatedly,
starting with Expr, until the result is no longer a macro call.
.IP
.nf
\f[C]
(macroexpand\-all\ expr\ {{environment}})
\f[]
.fi
.PP
Returns the expansion from the expression where all macro calls have
been expanded with macroexpand.
.PP
NOTE that when no explicit environment is given the macroexpand
functions then only the default built\-in macros will be expanded.
Inside macros and in the shell the variable $ENV is bound to the current
macro environment.
.IP
.nf
\f[C]
(eval\ expr\ {{environment}})
\f[]
.fi
.PP
Evaluate the expression expr.
Note that only the pre\-defined lisp functions, erlang BIFs and exported
functions can be called.
Also no local variables can be accessed.
To access local variables the expr to be evaluated can be wrapped in a
let defining these.
.PP
For example if the data we wish to evaluate is in the variable expr and
it assumes there is a local variable "foo" which it needs to access then
we could evaluate it by calling:
.IP
.nf
\f[C]
(eval\ `(let\ ((foo\ ,foo))\ ,expr))
\f[]
.fi
.SH Notes
.IP \[bu] 2
NYI \- Not Yet Implemented
.IP \[bu] 2
N.B.
\- Nota bene (note well)
.SH SEE ALSO
.PP
\f[B]lfe(1)\f[], \f[B]lfescript(1)\f[], \f[B]lfe_cl(3)\f[]
.SH AUTHORS
Robert Virding.
