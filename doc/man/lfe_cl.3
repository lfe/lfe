.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "lfe_cl" "3" "2017" "" ""
.hy
.SH NAME
.PP
lfe_cl \- LFE Common Lisp interface library
.SH SYNOPSIS
.PP
This module provides a set of Common Lisp functions and macros for use
in LFE.
The definitions closely follow the CL definitions and won\[aq]t be
documented here.
.SH DATA TYPES
.PP
The boolean values used here are the standard LFE \f[C]true\f[] and
\f[C]false\f[] and \f[B]NOT\f[] the Common Lisp values.
.SH EXPORTS
.SS Boolean conversion functions
.PP
\f[B]make\-lfe\-bool cl\-value\f[]
.PP
\f[B]make\-cl\-bool lfe\-bool\f[]
.SS Control structures
.PP
\f[B]\f[C]do\ vars\ (end\-test\ result)\ body\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [macro]\f[]\f[]
.PP
The value of \f[C]body\f[] is bound the variable \f[C]do\-state\f[]
which can be used when updating vars and in the \f[C]end\-test\f[].
This is the only way to get a value out of the body.
.PP
\f[B]mapcar function list\f[]
.PP
\f[B]maplist function list\f[]
.PP
\f[B]mapc function list\f[]
.PP
\f[B]mapl function list\f[]
.SS Symbol functions
.PP
\f[B]symbol\-plist symbol\f[]
.PP
\f[B]symbol\-name symbol\f[]
.PP
\f[B]get symbol pname\f[]
.PP
\f[B]get symbol pname default\f[]
.PP
\f[B]getl symbol pname\-list\f[]
.PP
\f[B]putprop symbol value pname\f[]
.PP
\f[B]remprop symbol pname\f[]
.PP
Atoms (symbols) in LFE don\[aq]t have property lists associated with
them.
However, here we have experimented with having a global ETS table
\f[C]lfe\-symbol\-plist\f[] which associates an atom with a property
list.
This is very unLFEy, but quite fun.
.SS Property list functions
.PP
\f[B]getf plist pname\f[]
.PP
\f[B]getf plist pname default\f[]
.PP
\f[B]putf plist value pname\f[]
.PP
\f[B]remf plist pname\f[]
.PP
\f[B]get\-properties plist pname\-list\f[]
.PP
The function \f[C]putf/3\f[] does not exist in Common Lisp but is
included to complete the operations on property lists.
.SS Simple sequence functions
.PP
\f[B]elt index sequence\f[]
.PP
\f[B]length sequence\f[]
.PP
\f[B]reverse sequence\f[]
.SS Concatenation, mapping and reducing functions
.PP
\f[B]some predicate sequence\f[]
.PP
\f[B]every predicate sequence\f[]
.PP
\f[B]notany predicate sequence\f[]
.PP
\f[B]notevery predicate sequence\f[]
.PP
\f[B]reduce function sequence\f[]
.PP
\f[B]reduce function sequence \[aq]initial\-value x\f[]
.PP
\f[B]reduce function sequence \[aq]from\-end \[aq]true\f[]
.PP
\f[B]reduce function sequence \[aq]initial\-value x \[aq]from\-end
\[aq]true\f[]
.SS Modifying sequences
.PP
\f[B]remove item sequence\f[]
.PP
\f[B]remove\-if predicate sequence\f[]
.PP
\f[B]remove\-if\-not predicate sequence\f[]
.PP
\f[B]remove\-duplicates sequence\f[]
.PP
\f[B]substitute new old sequence\f[]
.PP
\f[B]substitute\-if predicate sequence\f[]
.PP
\f[B]substitute\-if\-not predicate sequence\f[]
.SS Searching sequences
.PP
\f[B]find item sequence\f[]
.PP
\f[B]find\-if predicate sequence\f[]
.PP
\f[B]find\-if\-not predicate sequence\f[]
.PP
\f[B]find\-duplicates sequence\f[]
.PP
\f[B]position item sequence\f[]
.PP
\f[B]position\-if predicate sequence\f[]
.PP
\f[B]position\-if\-not predicate sequence\f[]
.PP
\f[B]position\-duplicates sequence\f[]
.PP
\f[B]count item sequence\f[]
.PP
\f[B]count\-if predicate sequence\f[]
.PP
\f[B]count\-if\-not predicate sequence\f[]
.SS Lists
.PP
\f[B]car list\f[]
.PP
\f[B]first list\f[]
.PP
\f[B]cdr list\f[]
.PP
\f[B]rest list\f[]
.PP
\f[B]nth index list\f[]
.PP
\f[B]nthcdr index list\f[]
.PP
\f[B]last list\f[]
.PP
\f[B]butlast list\f[]
.SS Substitution of expressions
.PP
\f[B]subst new old tree\f[]
.PP
\f[B]subst\-if new test tree\f[]
.PP
\f[B]subst\-if\-not new test tree\f[]
.PP
\f[B]sublis alist tree\f[]
.SS Lists as sets
.PP
\f[B]member item list\f[]
.PP
\f[B]member\-if predicate list\f[]
.PP
\f[B]member\-if\-not predicate list\f[]
.PP
\f[B]adjoin item list\f[]
.PP
\f[B]union list list\f[]
.PP
\f[B]intersection list list\f[]
.PP
\f[B]set\-difference list list\f[]
.PP
\f[B]set\-exclusive\-or list list\f[]
.PP
\f[B]subsetp list list\f[]
.SS Association list functions
.PP
\f[B]acons key data alist\f[]
.PP
\f[B]pairlis list list\f[]
.PP
\f[B]pairlis list list alist\f[]
.PP
\f[B]assoc key alist\f[]
.PP
\f[B]assoc\-if predicate alost\f[]
.PP
\f[B]assoc\-if\-not predicate alost\f[]
.PP
\f[B]rassoc key alist\f[]
.PP
\f[B]rassoc\-if predicate alost\f[]
.PP
\f[B]rassoc\-if\-not predicate alost\f[]
.SS Types
.PP
\f[B]type\-of object\f[]
.PP
\f[B]coerce object type\f[]
.SS Type testing macros
.PP
There is an include file which developers may which to utilize in their
LFE programs: \f[C](include\-lib\ "lfe/include/cl.lfe")\f[].
Currently this offers Common Lisp predicates, but may include other
useful macros and functions in the future.
The provided predicate macros wrap the various \f[C]is_*\f[] Erlang
functions; since these are expanded at compile time, they are usable in
guards.
It includes the following:
.PP
\f[B]alivep x\f[]
.PP
\f[B]atomp x\f[]
.PP
\f[B]binaryp x\f[]
.PP
\f[B]bitstringp x\f[]
.PP
\f[B]boolp x\f[]
.PP
\f[B]booleanp x\f[]
.PP
\f[B]builtinp x\f[]
.PP
\f[B]floatp x\f[]
.PP
\f[B]funcp x\f[]
.PP
\f[B]functionp x\f[]
.PP
\f[B]intp x\f[] and \f[B]integerp x\f[]
.PP
\f[B]listp x\f[]
.PP
\f[B]mapp x\f[]
.PP
\f[B]numberp x\f[]
.PP
\f[B]pidp x\f[]
.PP
\f[B]process\-alive\-p x\f[]
.PP
\f[B]recordp x tag\f[]
.PP
\f[B]recordp x tag size\f[]
.PP
\f[B]refp x\f[]
.PP
\f[B]referencep x\f[]
.PP
\f[B]tuplep x\f[]
.SH AUTHORS
Robert Virding.
