%% Copyright (c) 2024 Robert Virding
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

%% File    : lfe_repl_eval.erl
%% Author  : Robert Virding
%% Purpose : A simple Lisp Flavoured Erlang REPL evaluator.

-module(lfe_repl_eval).

-behaviour(gen_server).

-export([start/1,start_link/1,eval_form/2,get_state/1,set_state/2]).

-export([new_state/0,new_state/2,new_state/3,upd_state/3]).

-export([init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2]).

-include("lfe.hrl").

%% REPL state.
-record(state, {curr,                           %Current state
                save,                           %Saved slurp state
                base,                           %Base env
                slurp=false}).                  %Are we slurped?

%% API.

start(State) ->
    gen_server:start(?MODULE, State, []).

start_link(State) ->
    gen_server:start_link(?MODULE, State, []).

%% eval_form(ReplProcess, Form) ->
%%     {ok, Value, State} |
%%     {error, Reason, StackTrace} |
%%     {error, Reason, StackTrace} |
%%     {throw, Reason, StackTrace}.

eval_form(Repl, Form) ->
    gen_server:call(Repl, {eval_form, Form}).

get_state(Repl) ->
    gen_server:call(Repl, get_state).

set_state(Repl, State) ->
    gen_server:call(Repl, {set_state, State}).

%%
%% The gen server callbacks.
%%

init(State) ->
    {ok,State}.

handle_call({eval_form, Form}, From, State0) ->
    {Reply,State1} = handle_eval_form(Form, From, State0),
    %% Return the value.
    {reply,Reply,State1};
handle_call(get_state, _From, State) ->
    {reply,{ok,State},State};
handle_call({set_state, State}, _From, _OldState) ->
    {reply,ok,State}.

handle_cast({eval_expr, _Form}, State) ->
    {noreply,State}.

handle_info(_Msg, State) ->
    {noreply,State}.

terminate(_Reason, _State) ->
    ok.

handle_eval_form(Form, From, State0) ->
    try
        Ce1 = lfe_env:add_vbinding('-', Form, State0#state.curr),
        %% Macro expand and evaluate it.
        {Value,State1} = do_eval_form(Form, State0#state{curr=Ce1}),
        %% Update bindings.
        Ce2 = update_shell_vars(Form, Value, State1#state.curr),
        State2 = State1#state{curr=Ce2},
        {{ok,Value,State2},State2}
    catch
        exit:normal ->
            exit(normal);
        ?CATCH(Class, Reason, StackTrace)
            %% We don't want the ERROR REPORT generated by the
            %% emulator. Note: exit(kill) needs nothing special.
            ER = nocatch(Class, {Reason,StackTrace}),
            {Shell,_ReplyTag} = From,
            {links,LPs} = process_info(self(), links),
            lists:foreach(fun(P) -> exit(P, ER) end, LPs -- [Shell]),
            gen_server:reply(From, {Class,Reason,StackTrace}),
            %% Note we maybe linked to Shell so we don't crash here.
            exit(normal)
    end.

nocatch(throw, {Term,Stack}) ->
    {{nocatch,Term},Stack};
nocatch(_, Reason) -> Reason.

%% do_eval_form(Form, State) -> {Value,State}.
%%  Macro expand the the top form then treat special case top-level
%%  forms.

do_eval_form(Form, #state{curr=Ce}=St) ->
    %% Flatten progn nested forms.
    %% Don't deep expand, keep everything.
    case lfe_macro:expand_fileforms([{Form,1}], Ce, false, true) of
        {ok,Eforms,Ce1,Ws} ->
            list_warnings(Ws),
            St1 = St#state{curr=Ce1},
            foldl(fun ({F,_}, {_,S}) -> do_eval_form_1(F, S) end,
                  {[],St1}, Eforms);
        {error,Es,Ws} ->
            list_errors(Es),
            list_warnings(Ws),
            {error,St}
    end.

do_eval_form_1([progn|Eforms], St) ->           %Top-level nested progn
    foldl(fun (F, {_,S}) -> do_eval_form_1(F, S) end,
          {[],St}, Eforms);
do_eval_form_1([set|Rest], St0) ->
    {Value,St1} = set(Rest, St0),
    {Value,St1};
do_eval_form_1([slurp|Args], St0) ->            %Slurp in a file
    {Value,St1} = slurp(Args, St0),
    {Value,St1};
do_eval_form_1([unslurp|_], St) ->
    %% Forget everything back to before current slurp.
    unslurp(St);
do_eval_form_1([run|Args], St0) ->
    {Value,St1} = run_file(Args, St0),
    {Value,St1};
do_eval_form_1(['reset-environment'], #state{base=Be}=St) ->
    {ok,St#state{curr=Be}};
do_eval_form_1(['extend-module'|_], St) ->      %Maybe from macro expansion
    {[],St};
do_eval_form_1(['eval-when-compile'|_], St) ->  %Maybe from macro expansion
    %% We can happily ignore this.
    {[],St};
do_eval_form_1(['define-record',Name,Fields], #state{curr=Ce0}=St) ->
    %% Don't fully expand the record definition, push it till its used
    %% in the same way as function and macro definitions.
    Ce1 = lfe_env:add_record(Name, Fields, Ce0),
    {Name,St#state{curr=Ce1}};
do_eval_form_1(['define-function',Name,_Meta,Def], #state{curr=Ce0}=St) ->
    Ar = function_arity(Def),
    Ce1 = lfe_eval:add_dynamic_func(Name, Ar, Def, Ce0),
    {Name,St#state{curr=Ce1}};
do_eval_form_1(['define-macro',Name,_Meta,Def], #state{curr=Ce0}=St) ->
    Ce1 = lfe_env:add_mbinding(Name, Def, Ce0),
    {Name,St#state{curr=Ce1}};
do_eval_form_1(Expr, St) ->
    %% General case just evaluate the expression.
    {lfe_eval:expr(Expr, St#state.curr),St}.

function_arity([lambda,As|_]) ->
    length(As);
function_arity(['match-lambda',[Pats|_]|_]) ->
    length(Pats).

list_errors(Es) -> list_ews("~w: ~s\n", Es).

list_warnings(Ws) -> list_ews("~w: Warning: ~s\n", Ws).

list_ews(Format, Ews) ->
    lists:foreach(fun ({L,M,E}) ->
                          Cs = M:format_error(E),
                          lfe_io:format(Format, [L,Cs])
                  end, Ews).

%% set(Args, State) -> {Result,State}.

set([], St) -> {[],St};
set([Pat|Rest], #state{curr=Ce}=St) ->
    Epat = lfe_macro:expand_expr_all(Pat, Ce),  %Expand macros in pattern
    set_1(Epat, Rest, St).

set_1(Pat, [['when'|_]=G,Exp], St) ->
    set_1(Pat, [G], Exp, St);                   %Just the guard
set_1(Pat, [Exp], St) ->
    set_1(Pat, [], Exp, St);                    %Empty guard body
set_1(_, _, _) -> erlang:error({bad_form,'set'}).

set_1(Pat, Guard, Exp, #state{curr=Ce0}=St) ->
    Val = lfe_eval:expr(Exp, Ce0),              %Evaluate expression
    case lfe_eval:match_when(Pat, Val, Guard, Ce0) of
        {yes,_,Bs} ->
            Ce1 = foldl(fun ({N,V}, E) -> lfe_env:add_vbinding(N, V, E) end,
                        Ce0, Bs),
            {Val,St#state{curr=Ce1}};
        no -> erlang:error({badmatch,Val})
    end.

%% unslurp(State) -> {ok,State}.
%% slurp(File, State) -> {{ok,Mod},State}.
%%  Load in a file making all the functions and macros available.
%%  There is a bit of trickery to get hold of the compile environment
%%  to get hold of the macros. We call the compiler directly but don't
%%  make the LFE-EXPAND-EXPORTED-MACRO/3 function.

-record(slurp, {mod,funs=[],imps=[],recs=[]}).  %For slurping

unslurp(St0) ->
    St1 = case St0#state.slurp of
              true ->                           %Roll-back slurp
                  Se = St0#state.save,
                  St0#state{curr=Se,save=none,slurp=false};
              false -> St0                      %Do nothing
          end,
    {ok,St1}.

slurp([File], St0) ->
    {ok,#state{curr=Ce0}=St1} = unslurp(St0),   %Reset the environment
    Name = lfe_eval:expr(File, Ce0),            %Get file name
    case slurp_1(Name, Ce0) of
        {ok,Mod,Ce1} ->                         %Set the new environment
            {{ok,Mod},St1#state{curr=Ce1,save=Ce0,slurp=true}};
        error ->
            {error,St1}
    end.

slurp_1(Name, Ce) ->
    case slurp_file(Name) of
        {ok,Mod,Fs,Env0,Ws} ->
            slurp_warnings(Ws),
            %% Collect functions and imports.
            Sl0 = #slurp{mod=Mod,funs=[],imps=[],recs=[]},
            Sl1 = lists:foldl(fun collect_module/2, Sl0, Fs),
            %% Add imports to environment.
            Ifun = fun ({M,Is}, Env) ->
                           foldl(fun ({{F,A},R}, E) ->
                                         lfe_env:add_ibinding(M, F, A, R, E)
                                 end, Env, Is)
                   end,
            Env1 = foldl(Ifun, Env0, Sl1#slurp.imps),
            %% Add functions to environment.
            Env2 = foldl(fun ({N,Ar,Def}, Env) ->
                                 lfe_eval:add_dynamic_func(N, Ar, Def, Env)
                         end, Env1, Sl1#slurp.funs),
            %% Add records to the environment.
            Env3 = foldl(fun ({R,Rfs}, Env) ->
                                 lfe_env:add_record(R, Rfs, Env)
                         end, Env2, Sl1#slurp.recs),
            {ok,Mod,lfe_env:add_env(Env3, Ce)};
        {error,Mews,Es,Ws} ->
            slurp_errors(Es),
            slurp_warnings(Ws),
            %% Now the errors and warnings for each module.
            lists:foreach(fun ({error,Mes,Mws}) ->
                                  slurp_errors(Mes),
                                  slurp_warnings(Mws)
                          end, Mews),
            error
    end.

slurp_file(Name) ->
    case lfe_comp:file(Name, [binary,to_split,return]) of
        {ok,[{ok,Mod,Fs0,_}|_],Ws} ->           %Only do first module
            %% Deep expand, don't keep everything.
            case lfe_macro:expand_fileforms(Fs0, lfe_env:new(), true, false) of
                {ok,Fs1,Env,_} ->
                    %% Flatten and trim away any eval-when-compile.
                    {Fs2,42} = lfe_lib:proc_forms(fun slurp_form/3, Fs1, 42),
                    case lfe_lint:module(Fs2) of
                        {ok,_,Lws} -> {ok,Mod,Fs2,Env,Ws ++ Lws};
                        {error,Les,Lws} ->
                            slurp_error_ret(Name, Les, Ws ++ Lws)
                    end;
                {error,Ees,Ews} ->
                    slurp_error_ret(Name, Ees, Ws ++ Ews)
            end;
        Error -> Error
    end.

slurp_error_ret(Name, Es, Ws) ->
    {error,[],[{Name,Es}],[{Name,Ws}]}.

slurp_form(['eval-when-compile'|_], _, D) -> {[],D};
slurp_form(F, L, D) -> {[{F,L}],D}.

collect_module({['define-module',Mod,Meta,Atts],_}, Sl0) ->
    Sl1 = collect_meta(Meta, Sl0),
    Sl2 = collect_attrs(Atts, Sl1),
    Sl2#slurp{mod=Mod};
collect_module({['extend-module',Meta,Atts],_}, Sl0) ->
    Sl1 = collect_meta(Meta, Sl0),
    collect_attrs(Atts, Sl1);
collect_module({['define-function',F,_Meta,Def],_}, #slurp{funs=Fs}=Sl) ->
    Ar = function_arity(Def),
    Sl#slurp{funs=[{F,Ar,Def}|Fs]};
collect_module({['define-record',R,Fs],_}, #slurp{recs=Rs}=Sl) ->
    Sl#slurp{recs=[{R,Fs}|Rs]};
%% Ignore other forms, type and spec defs.
collect_module({_,_}, Sl) ->
    Sl.

collect_meta(_, St) -> St.

collect_attrs([[import|Is]|Atts], St) ->
    collect_attrs(Atts, collect_imps(Is, St));
collect_attrs([_|Atts], St) ->                  %Ignore everything else
    collect_attrs(Atts, St);
collect_attrs([], St) -> St.

collect_imps(Is, St) ->
    foldl(fun (I, S) -> collect_imp(I, S) end, St, Is).

collect_imp(['from',Mod|Fs], St) ->
    collect_imp(fun ([F,A], Imps) -> orddict:store({F,A}, F, Imps) end,
                Mod, St, Fs);
collect_imp(['rename',Mod|Rs], St) ->
    collect_imp(fun ([[F,A],R], Imps) -> orddict:store({F,A}, R, Imps) end,
                Mod, St, Rs);
collect_imp(_, St) -> St.                       %Ignore everything else

collect_imp(Fun, Mod, St, Fs) ->
    Imps0 = safe_fetch(Mod, St#slurp.imps, []),
    Imps1 = foldl(Fun, Imps0, Fs),
    St#slurp{imps=orddict:store(Mod, Imps1, St#slurp.imps)}.

%% slurp_errors([File, ]Errors) -> ok.
%% slurp_warnings([File, ]Warnings) -> ok.
%%  Print errors and warnings.

slurp_errors(Errors) ->
    lists:foreach(fun ({File,Es}) -> slurp_errors(File, Es) end, Errors).

slurp_errors(File, Es) -> slurp_ews(File, "~s:~w: ~s\n", Es).

slurp_warnings(Warnings) ->
    lists:foreach(fun ({File,Ws}) -> slurp_warnings(File, Ws) end, Warnings).

slurp_warnings(File, Es) -> slurp_ews(File, "~s:~w: Warning: ~s\n", Es).

slurp_ews(File, Format, Ews) ->
    lists:foreach(fun ({Line,Mod,Error}) ->
                          Cs = Mod:format_error(Error),
                          lfe_io:format(Format, [File,Line,Cs])
                  end, Ews).

%% run_file(Args, State) -> {Value,State}.
%%  Run the shell expressions in a file. Abort on errors and only
%%  return updated state if there are no errors.

run_file([File], #state{curr=Ce}=St) ->
    Name = lfe_eval:expr(File, Ce),             %Get file name
    case read_script_file(Name) of              %Read the file
        {ok,Forms} ->
            run_loop(Forms, St);
        {error,E} ->
            slurp_errors(Name, [E]),
            {error,St}
    end.

%% read_script_file(FileName) -> {ok,[Sexpr]} | {error,Error}.
%%  Read a file returning the sexprs. Almost the same as
%%  lfe_io:read_file except the we skip the first line if it is a
%%  script line "#! ... ".

read_script_file(File) ->
    case file:open(File, [read]) of
        {ok,Fd} ->
            %% Check if first a script line, if so skip it.
            case io:get_line(Fd, '') of
                "#!" ++ _ ->
                    lfe_io:read_file(Fd, 2);
                _ -> 
                    file:position(Fd, bof),    %Reset to start of file
                    lfe_io:read_file(Fd, 1)
            end
    end.

%% read_script_string(FileName) -> {ok,[Sexpr]} | {error,Error}.
%%  Read a file returning the sexprs. Almost the same as
%%  lfe_io:read_string except parse all forms.

%% read_script_string(String) ->
%%     lfe_io:read_string(String).

%% run_loop(Forms, State) -> {Value,State}.
%% run_loop(Forms PrevValue, State) -> {Value,State}.

run_loop(Fs, St) -> run_loop(Fs, [], St).

run_loop([F|Fs], _, St0) ->
    Ce1 = lfe_env:add_vbinding('-', F, St0#state.curr),
    {Value,St1} = eval_form(F, St0#state{curr=Ce1}),
    Ce2 = update_shell_vars(F, Value, St1#state.curr),
    run_loop(Fs, Value, St1#state{curr=Ce2});
run_loop([], Value, St) -> {Value,St}.

%% safe_fetch(Key, Dict, Default) -> Value.

safe_fetch(Key, D, Def) ->
    case orddict:find(Key, D) of
        {ok,Val} -> Val;
        error -> Def
    end.

%%
%% Creating and managing the state.
%%

%% new_state() -> State.
%% new_state(Args [,Env]) -> State.
%% new_state(ScriptName, Args [,Env]) -> State.
%%  Generate a new shell state with all the default functions, macros
%%  and variables.

new_state() ->
    new_state("lfe", []).

new_state(Script, Args) ->
    new_state(Script, Args, lfe_env:new()).

new_state(Script, Args, Env0) ->
    Env1 = lfe_env:add_vbinding('script-name', Script, Env0),
    Env2 = lfe_env:add_vbinding('script-args', Args, Env1),
    Base0 = add_shell_functions(Env2),
    Base1 = add_shell_macros(Base0),
    Base2 = add_shell_vars(Base1),
    #state{curr=Base2,save=Base2,base=Base2,slurp=false}.

upd_state(Script, Args, #state{curr=Curr,save=Save,base=Base}=St) ->
    %% Update an environment with with script name and args.
    Upd = fun (E0) ->
                  E1 = lfe_env:add_vbinding('script-name', Script, E0),
                  lfe_env:add_vbinding('script-args', Args, E1)
          end,
    St#state{curr=Upd(Curr),save=Upd(Save),base=Upd(Base)}.

add_shell_vars(Env0) ->
    %% Add default shell expression variables.
    Env1 = foldl(fun (Symb, E) -> lfe_env:add_vbinding(Symb, [], E) end, Env0,
                 ['+','++','+++','-','*','**','***']),
    lfe_env:add_vbinding('$ENV', Env1, Env1).   %This gets it all

update_shell_vars(Form, Value, Env0) ->
    Env1 = foldl(fun ({Symb,Val}, E) -> lfe_env:add_vbinding(Symb, Val, E) end,
                 Env0,
                 [{'+++',lfe_env:fetch_vbinding('++', Env0)},
                  {'++',lfe_env:fetch_vbinding('+', Env0)},
                  {'+',Form},
                  {'***',lfe_env:fetch_vbinding('**', Env0)},
                  {'**',lfe_env:fetch_vbinding('*', Env0)},
                  {'*',Value}]),
    %% Be cunning with $ENV, remove self references so it doesn't grow
    %% indefinitely.
    Env2 = lfe_env:del_vbinding('$ENV', Env1),
    lfe_env:add_vbinding('$ENV', Env2, Env2).

add_shell_functions(Env0) ->
    Fs = [
          {cd,1,[lambda,[d],[':',lfe_repl_bifs,cd,d]]},
          {ep,1,[lambda,[e],[':',lfe_repl_bifs,ep,e]]},
          {ep,2,[lambda,[e,d],[':',lfe_repl_bifs,ep,e,d]]},
          {epp,1,[lambda,[e],[':',lfe_repl_bifs,epp,e]]},
          {epp,2,[lambda,[e,d],[':',lfe_repl_bifs,epp,e,d]]},
          {h,0,[lambda,[],[':',lfe_repl_bifs,help]]},
          {h,1,[lambda,[m], [':',lfe_repl_bifs,h,m]]},
          {h,2,[lambda,[m,f], [':',lfe_repl_bifs,h,m,f]]},
          {h,3,[lambda,[m,f,a], [':',lfe_repl_bifs,h,m,f,a]]},

          {help,0,[lambda,[],[':',lfe_repl_bifs,help]]},
          {i,0,[lambda,[],[':',lfe_repl_bifs,i]]},
          {i,1,[lambda,[ps],[':',lfe_repl_bifs,i,ps]]},
          {i,3,[lambda,[x,y,z],[':',lfe_repl_bifs,i,x,y,z]]},
          {clear,0,[lambda,[],[':',lfe_repl_bifs,clear]]},
          {pid,3,[lambda,[i,j,k],[':',lfe_repl_bifs,pid,i,j,k]]},
          {p,1,[lambda,[e],[':',lfe_repl_bifs,p,e]]},
          {p,2,[lambda,[e,d],[':',lfe_repl_bifs,p,e,d]]},
          {pp,1,[lambda,[e],[':',lfe_repl_bifs,pp,e]]},
          {pp,2,[lambda,[e,d],[':',lfe_repl_bifs,pp,e,d]]},
          {pwd,0,[lambda,[],[':',lfe_repl_bifs,pwd]]},
          {q,0,[lambda,[],[':',lfe_repl_bifs,exit]]},
          {flush,0,[lambda,[],[':',lfe_repl_bifs,flush]]},
          {regs,0,[lambda,[],[':',lfe_repl_bifs,regs]]},
          {nregs,0,[lambda,[],[':',lfe_repl_bifs,nregs]]},
          {memory,0,[lambda,[],[':',lfe_repl_bifs,memory]]},
          {memory,1,[lambda,[t],[':',lfe_repl_bifs,memory,t]]},
          {uptime,0,[lambda,[],[':',lfe_repl_bifs,uptime]]},
          {exit,0,[lambda,[],[':',lfe_repl_bifs,exit]]}
         ],
    %% Any errors here will crash shell startup!
    Add = fun ({N,Ar,Def}, E) ->
                  lfe_eval:add_dynamic_func(N, Ar, Def, E)
          end,
    Env1 = foldl(Add, Env0, Fs),
    Env1.

%% Last clause in match-lambda macro to catch-all as undefined function.
-define(UNDEF_MATCH_FUNC(Name),
        [[args,'ENV'],?BQ([error,{undefined_func,{Name,?C([length,args])}}])]).

add_shell_macros(Env0) ->
    %% We KNOW how macros are expanded and write them directly in
    %% expanded form here.
    Ms = [{c,[lambda,[args,'$ENV'],?BQ([':',lfe_repl_bifs,c,?C_A(args)])]},
          {describe,['match-lambda',
                     [[[list,mod],'$ENV'],
                      ?BQ([':',lfe_repl_bifs,doc,?Q(?C(mod))])],
                     ?UNDEF_MATCH_FUNC(describe)]},
          {doc,['match-lambda',
                [[[list,mod],'$ENV'],?BQ([':',lfe_repl_bifs,h,?Q(?C(mod))])],
                [[[list,mod,func],'$ENV'],
                 ?BQ([':',lfe_repl_bifs,h,?Q(?C(mod)),?Q(?C(func))])],
                [[[list,mod,func,arity],'$ENV'],
                 ?BQ([':',lfe_repl_bifs,h,?Q(?C(mod)),?Q(?C(func)),?Q(?C(arity))])],
                ?UNDEF_MATCH_FUNC(doc)]},
          {ec,[lambda,[args,'$ENV'],?BQ([':',lfe_repl_bifs,ec,?C_A(args)])]},
          {l,[lambda,[args,'$ENV'],?BQ([':',lfe_repl_bifs,l,[list|?C(args)]])]},
          {ls,[lambda,[args,'$ENV'],?BQ([':',lfe_repl_bifs,ls,[list|?C(args)]])]},
          {m,['match-lambda',
              [[[],'$ENV'],?BQ([':',lfe_repl_bifs,m])],
              [[ms,'$ENV'],?BQ([':',lfe_repl_bifs,m,[list|?C(ms)]])]]}
         ],
    %% Any errors here will crash shell startup!
    Env1 = lfe_env:add_mbindings(Ms, Env0),
    %% io:fwrite("asm: ~p\n", [Env1]),
    Env1.

%% Implement our own lists functions to get around stacktrace printing
%% problems.

foldl(F, Accu, [Hd|Tail]) ->
    foldl(F, F(Hd, Accu), Tail);
foldl(F, Accu, []) when is_function(F, 2) -> Accu.

%% Some example erlang shell and lfe repl commands to test it.
%% St = lfe_repl_eval:new_state().
%% {ok,R} = lfe_repl_eval:start(St).
%% lfe_repl_eval:eval_form(R, [time]).
%% lfe_repl_eval:eval_form(R, ['+',1,2]).
%% lfe_repl_eval:eval_form(R, ['+',1,a]).
%% lfe_repl_eval:eval_form(R, [defun,a,[x,y],['*',x,y]]).
%% lfe_repl_eval:eval_form(R, [a,34,56]).
%% lfe_repl_eval:eval_form(R, [uptime]).

%% (set st (: lfe_repl_eval new_state))
%% (set `#(ok ,r) (: lfe_repl_eval start st))
%% (: lfe_repl_eval eval_form r '(time))
%% (: lfe_repl_eval eval_form r (+ 1 2))
%% (: lfe_repl_eval eval_form r '(+ 1 a))
%% (: lfe_repl_eval eval_form r '(defun a (x y) (* x y)))
%% (: lfe_repl_eval eval_form r '(a 45 56))
%% (: lfe_repl_eval eval_form r '(uptime))
